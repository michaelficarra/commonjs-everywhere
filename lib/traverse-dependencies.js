// Generated by CoffeeScript 2.0.0-beta7
void function () {
  var badRequireError, canonicalise, escodegen, esprima, estraverse, fs, path, relativeResolve, util;
  fs = require('fs');
  path = require('path');
  util = require('util');
  esprima = require('esprima');
  estraverse = require('estraverse');
  escodegen = require('escodegen');
  canonicalise = require('./canonicalise');
  relativeResolve = require('./relative-resolve');
  badRequireError = function (filename, node, msg) {
    if (null != node.loc && null != (null != node.loc ? node.loc.start : void 0))
      filename = '' + filename + ':' + node.loc.start.line + ':' + node.loc.start.column;
    throw 'illegal require: ' + msg + '\n  `' + require('escodegen').generate(node) + '`\n  in ' + filename + '';
  };
  module.exports = function (entryPoint, options) {
    var aliases, ast, astOrJs, cache$, cache$1, cache$2, canonicalName, checked, deps, ext, extensions, extname, filename, handler, handlers, lineCount, mtime, name, processed, root, src, srcMap, uidFor, worklist;
    aliases = null != options.aliases ? options.aliases : {};
    uidFor = options.uidFor;
    root = options.root;
    handlers = {
      '.coffee': function (coffee, canonicalName) {
        return CoffeeScript.compile(CoffeeScript.parse(coffee, { raw: true }), { bare: true });
      },
      '.json': function (json, canonicalName) {
        return esprima.parse('module.exports = ' + json, {
          loc: true,
          source: canonicalName
        });
      }
    };
    for (ext in cache$ = null != options.handlers ? options.handlers : {}) {
      if (!isOwn$(cache$, ext))
        continue;
      handler = cache$[ext];
      handlers[ext] = handler;
    }
    extensions = ['.js'].concat([].slice.call(function (accum$) {
      for (ext in handlers) {
        if (!isOwn$(handlers, ext))
          continue;
        accum$.push(ext);
      }
      return accum$;
    }.call(this, [])));
    worklist = [relativeResolve({
        extensions: extensions,
        aliases: aliases,
        root: root,
        path: entryPoint
      })];
    processed = options.processed || {};
    checked = {};
    while (worklist.length) {
      cache$1 = worklist.pop();
      filename = cache$1.filename;
      canonicalName = cache$1.canonicalName;
      if (!filename)
        continue;
      if ({}.hasOwnProperty.call(checked, filename))
        continue;
      checked[filename] = true;
      extname = path.extname(filename);
      mtime = fs.statSync(filename).mtime.getTime();
      if ((null != processed[filename] ? processed[filename].mtime : void 0) === mtime) {
        worklist = worklist.concat(processed[filename].deps);
        continue;
      }
      src = fs.readFileSync(filename).toString();
      astOrJs = {}.hasOwnProperty.call(handlers, extname) ? handlers[extname](src, canonicalName) : src;
      ast = typeof astOrJs === 'string' ? function () {
        var e;
        try {
          return esprima.parse(astOrJs, {
            loc: true,
            source: canonicalName
          });
        } catch (e$) {
          e = e$;
          throw new Error('Syntax error in ' + filename + ' at line ' + e.lineNumber + ', column ' + e.column + e.message.slice(e.message.indexOf(':')));
        }
      }.call(this) : astOrJs;
      if (null != ast.loc)
        ast.loc;
      else
        ast.loc = {};
      deps = [];
      name = uidFor(canonicalName);
      estraverse.replace(ast, {
        enter: function (node, parents) {
          var cwd, e, resolved;
          if (null != node.loc)
            node.loc.source = canonicalName;
          if (!(node.type === 'CallExpression' && node.callee.type === 'Identifier' && node.callee.name === 'require'))
            return;
          if (!(node['arguments'].length === 1))
            badRequireError(filename, node, 'require must be given exactly one argument');
          if (!(node['arguments'][0].type === 'Literal' && typeof node['arguments'][0].value === 'string'))
            badRequireError(filename, node, 'argument of require must be a constant string');
          cwd = path.dirname(fs.realpathSync(filename));
          if (options.verbose)
            console.error('required "' + node['arguments'][0].value + '" from "' + canonicalName + '"');
          try {
            resolved = relativeResolve({
              extensions: extensions,
              aliases: aliases,
              root: options.root,
              cwd: cwd,
              path: node['arguments'][0].value
            });
            worklist.push(resolved);
            deps.push(resolved);
          } catch (e$) {
            e = e$;
            if (options.ignoreMissing) {
              return {
                type: 'Literal',
                value: null
              };
            } else {
              throw e;
            }
          }
          return {
            type: 'CallExpression',
            callee: node.callee,
            'arguments': [
              {
                type: 'Literal',
                value: uidFor(resolved.canonicalName)
              },
              {
                type: 'Identifier',
                name: 'module'
              }
            ]
          };
        }
      });
      cache$2 = escodegen.generate(ast, {
        sourceMap: true,
        format: escodegen.FORMAT_DEFAULTS,
        sourceMapWithCode: true,
        sourceMapRoot: null != options.sourceMap ? path.relative(path.dirname(options.sourceMap), options.root) || '.' : void 0
      });
      src = cache$2.code;
      srcMap = cache$2.map;
      srcMap = srcMap.toString();
      lineCount = src.split('\n').length - 1;
      processed[filename] = {
        name: name,
        src: src,
        srcMap: srcMap,
        lineCount: lineCount,
        mtime: mtime,
        deps: deps
      };
    }
    return processed;
  };
  function isOwn$(o, p) {
    return {}.hasOwnProperty.call(o, p);
  }
}.call(this);
