// Generated by CoffeeScript 2.0.0-beta5
void function () {
  var $0, _, aliasPair, btoa, build, cache$, cache$1, CJSEverywhere, dep, deps, escodegen, escodegenCompactFormat, escodegenDefaultFormat, fs, handlerPair, knownOpts, match, nopt, optAliases, options, originalEntryPoint, path, positionalArgs, root, startBuild, stdinput;
  fs = require('fs');
  path = require('path');
  escodegen = require('escodegen');
  nopt = require('nopt');
  btoa = require('Base64').btoa;
  CJSEverywhere = require('./module');
  escodegenDefaultFormat = {
    indent: {
      style: '  ',
      base: 0
    },
    renumber: true,
    hexadecimal: true,
    quotes: 'auto',
    parentheses: false
  };
  escodegenCompactFormat = {
    indent: {
      style: '',
      base: 0
    },
    renumber: true,
    hexadecimal: true,
    quotes: 'auto',
    escapeless: true,
    compact: true,
    parentheses: false,
    semicolons: false
  };
  knownOpts = {
    deps: Boolean,
    help: Boolean,
    minify: Boolean,
    node: Boolean,
    verbose: Boolean,
    version: Boolean,
    watch: Boolean,
    'ignore-missing': Boolean,
    'inline-source-map': Boolean,
    'inline-sources': Boolean,
    'export': String,
    output: String,
    root: String,
    'source-map': String,
    alias: [
      String,
      Array
    ],
    handler: [
      String,
      Array
    ]
  };
  optAliases = {
    a: '--alias',
    h: '--handler',
    m: '--minify',
    o: '--output',
    r: '--root',
    s: '--source-map',
    v: '--verbose',
    w: '--watch',
    x: '--export'
  };
  options = nopt(knownOpts, optAliases, process.argv, 2);
  positionalArgs = options.argv.remain;
  delete options.argv;
  if (null != options.node)
    options.node;
  else
    options.node = true;
  if (null != options['inline-sources'])
    options['inline-sources'];
  else
    options['inline-sources'] = true;
  if (null != options.alias)
    options.alias;
  else
    options.alias = [];
  if (null != options.handler)
    options.handler;
  else
    options.handler = [];
  options.ignoreMissing = options['ignore-missing'];
  options.sourceMap = options['source-map'];
  options.inlineSources = options['inline-sources'];
  options.inlineSourceMap = options['inline-source-map'];
  if (options.help) {
    $0 = process.argv[0] === 'node' ? process.argv[1] : process.argv[0];
    $0 = path.basename($0);
    console.log('\n  Usage: ' + $0 + ' OPT* path/to/entry-file.ext OPT*\n\n  -a, --alias ALIAS:TO      replace requires of file identified by ALIAS with TO\n  -h, --handler EXT:MODULE  handle files with extension EXT with module MODULE\n  -m, --minify              minify output\n  -o, --output FILE         output to FILE instead of stdout\n  -r, --root DIR            unqualified requires are relative to DIR; default: cwd\n  -s, --source-map FILE     output a source map to FILE\n  -v, --verbose             verbose output sent to stderr\n  -w, --watch               watch input files/dependencies for changes and rebuild bundle\n  -x, --export NAME         export the given entry module as NAME\n  --deps                    do not bundle; just list the files that would be bundled\n  --help                    display this help message and exit\n  --ignore-missing          continue without error when dependency resolution fails\n  --inline-source-map       include the source map as a data URI in the generated bundle\n  --inline-sources          include source content in generated source maps; default: on\n  --node                    include process object; emulate node environment; default: on\n  --version                 display the version number and exit\n');
    process.exit(0);
  }
  if (options.version) {
    console.log(require('../package.json').version);
    process.exit(0);
  }
  if (!(positionalArgs.length === 1)) {
    console.error('wrong number of entry points given; expected 1');
    process.exit(1);
  }
  options.aliases = {};
  for (var i$ = 0, length$ = options.alias.length; i$ < length$; ++i$) {
    aliasPair = options.alias[i$];
    match = aliasPair.match((cache$ = /([^:]+):(.*)/, null != cache$ ? cache$ : []));
    if (null != match) {
      options.aliases[match[1]] = match[2];
    } else {
      console.error('invalid alias: ' + aliasPair);
      process.exit(1);
    }
  }
  delete options.alias;
  options.handlers = {};
  for (var i$1 = 0, length$1 = options.handler.length; i$1 < length$1; ++i$1) {
    handlerPair = options.handler[i$1];
    match = handlerPair.match((cache$1 = /([^:]+):(.*)/, null != cache$1 ? cache$1 : []));
    if (null != match) {
      (function (ext, mod) {
        return options.handlers[ext] = require(mod);
      }('.' + match[1], match[2]));
    } else {
      console.error('invalid handler: ' + handlerPair);
      process.exit(1);
    }
  }
  delete options.handler;
  root = options.root ? path.resolve(options.root) : process.cwd();
  originalEntryPoint = positionalArgs[0];
  if (options.deps) {
    deps = CJSEverywhere.traverseDependencies(originalEntryPoint, root, options);
    for (_ in deps) {
      if (!isOwn$(deps, _))
        continue;
      dep = deps[_];
      console.log(dep.canonicalName);
    }
    process.exit(0);
  }
  if (options.watch && !options.output) {
    console.error('--watch requires --ouput');
    process.exit(1);
  }
  build = function (entryPoint, processed) {
    var bundled, cache$2, cache$3, canonicalName, code, datauri, e, esmangle, file, fileContents, filename, map, newDeps, sourceMappingUrl;
    if (null == processed)
      processed = {};
    try {
      newDeps = CJSEverywhere.traverseDependencies(entryPoint, root, options);
      if (options.watch)
        for (filename in newDeps) {
          if (!isOwn$(newDeps, filename))
            continue;
          dep = newDeps[filename];
          console.error('built ' + dep.canonicalName + ' (' + options.cache[filename] + ')');
        }
      for (file in newDeps) {
        if (!isOwn$(newDeps, file))
          continue;
        processed[file] = newDeps[file];
      }
    } catch (e$) {
      e = e$;
      if (options.watch) {
        console.error('ERROR: ' + e.message);
      } else {
        throw e;
      }
    }
    bundled = CJSEverywhere.bundle(processed, originalEntryPoint, root, options);
    if (options.minify) {
      esmangle = require('esmangle');
      bundled = esmangle.mangle(esmangle.optimize(bundled), { destructive: true });
    }
    cache$2 = escodegen.generate(bundled, {
      comment: !options.minify,
      sourceMap: true,
      sourceMapWithCode: true,
      sourceMapRoot: null != options.sourceMap ? path.relative(path.dirname(options.sourceMap), root) || '.' : void 0,
      format: options.minify ? escodegenCompactFormat : escodegenDefaultFormat
    });
    code = cache$2.code;
    map = cache$2.map;
    if ((options.sourceMap || options.inlineSourceMap) && options.inlineSources)
      for (filename in processed) {
        if (!isOwn$(processed, filename))
          continue;
        {
          cache$3 = processed[filename];
          canonicalName = cache$3.canonicalName;
          fileContents = cache$3.fileContents;
        }
        map.setSourceContent(canonicalName, fileContents);
      }
    if (options.sourceMap) {
      fs.writeFileSync(options.sourceMap, '' + map);
      sourceMappingUrl = options.output ? path.relative(path.dirname(options.output), options.sourceMap) : options.sourceMap;
      if (!options.inlineSourceMap)
        code = '' + code + '\n//# sourceMappingURL=' + sourceMappingUrl;
    }
    if (options.inlineSourceMap) {
      datauri = 'data:application/json;charset=utf-8;base64,' + btoa('' + map);
      code = '' + code + '\n//# sourceMappingURL=' + datauri;
    }
    if (options.output) {
      fs.writeFileSync(options.output, code);
    } else {
      process.stdout.write('' + code + '\n');
    }
    if (options.watch || options.verbose)
      console.error('BUNDLE COMPLETE');
    return processed;
  };
  startBuild = function () {
    var processed, startWatching, watching;
    if (options.watch) {
      options.cache = {};
      console.error('BUNDLING starting at ' + originalEntryPoint);
    }
    processed = build(originalEntryPoint);
    if (options.watch) {
      watching = [];
      return (startWatching = function (processed) {
        return function (accum$) {
          var canonicalName, file;
          for (file in processed) {
            if (!isOwn$(processed, file))
              continue;
            canonicalName = processed[file].canonicalName;
            if (!!in$(file, watching))
              continue;
            accum$.push(function (file, canonicalName) {
              watching.push(file);
              return fs.watchFile(file, {
                persistent: true,
                interval: 500
              }, function (curr, prev) {
                var ino;
                ino = process.platform === 'win32' ? null != curr.ino : curr.ino;
                if (!ino) {
                  console.error('WARNING: watched file ' + file + ' has disappeared');
                  return;
                }
                console.error('REBUNDLING starting at ' + canonicalName);
                processed = build(file, processed);
                startWatching(processed);
              });
            }(file, canonicalName));
          }
          return accum$;
        }.call(this, []);
      })(processed);
    }
  };
  if (originalEntryPoint === '-') {
    stdinput = '';
    process.stdin.on('data', function (data) {
      return stdinput += data;
    });
    process.stdin.on('end', function () {
      originalEntryPoint = require('mktemp').createFileSync('temp-XXXXXXXXX.js');
      fs.writeFileSync(originalEntryPoint, stdinput);
      process.on('exit', function () {
        return fs.unlinkSync(originalEntryPoint);
      });
      return startBuild();
    });
    process.stdin.setEncoding('utf8');
    process.stdin.resume();
  } else {
    startBuild();
  }
  function isOwn$(o, p) {
    return {}.hasOwnProperty.call(o, p);
  }
  function in$(member, list) {
    for (var i = 0, length = list.length; i < length; ++i)
      if (i in list && list[i] === member)
        return true;
    return false;
  }
}.call(this);
