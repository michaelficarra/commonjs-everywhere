// Generated by CoffeeScript 2.0.0-beta5
void function () {
  var $0, _, aliasPair, btoa, build, cache$, cache$1, cache$2, CJSEverywhere, dep, deps, escodegen, escodegenCompactFormat, escodegenDefaultFormat, fs, handlerPair, Jedediah, match, optionParser, options, originalEntryPoint, path, positionalArgs, root, startBuild, stdinput;
  fs = require('fs');
  path = require('path');
  escodegen = require('escodegen');
  Jedediah = require('jedediah');
  btoa = require('Base64').btoa;
  CJSEverywhere = require('./module');
  escodegenDefaultFormat = {
    indent: {
      style: '  ',
      base: 0
    },
    renumber: true,
    hexadecimal: true,
    quotes: 'auto',
    parentheses: false
  };
  escodegenCompactFormat = {
    indent: {
      style: '',
      base: 0
    },
    renumber: true,
    hexadecimal: true,
    quotes: 'auto',
    escapeless: true,
    compact: true,
    parentheses: false,
    semicolons: false
  };
  optionParser = new Jedediah;
  optionParser.addOption('help', false, 'display this help message and exit');
  optionParser.addOption('version', false, 'display the version number and exit');
  optionParser.addOption('deps', false, 'do not bundle; just list the files that would be bundled');
  optionParser.addOption('node', true, 'include process object; emulate node environment; default: on');
  optionParser.addOption('minify', 'm', false, 'minify output');
  optionParser.addOption('ignore-missing', false, 'continue without error when dependency resolution fails');
  optionParser.addOption('inline-sources', true, 'include source content in generated source maps; default: on');
  optionParser.addOption('inline-source-map', false, 'include the source map as a data URI in the generated bundle');
  optionParser.addOption('watch', 'w', false, 'watch input files/dependencies for changes and rebuild bundle');
  optionParser.addOption('verbose', 'v', false, 'verbose output sent to stderr');
  optionParser.addParameter('export', 'x', 'NAME', 'export the given entry module as NAME');
  optionParser.addParameter('output', 'o', 'FILE', 'output to FILE instead of stdout');
  optionParser.addParameter('root', 'r', 'DIR', 'unqualified requires are relative to DIR; default: cwd');
  optionParser.addParameter('source-map', 's', 'FILE', 'output a source map to FILE');
  optionParser.addListParameter('alias', 'a', 'ALIAS:TO', 'replace requires of file identified by ALIAS with TO');
  optionParser.addListParameter('handler', 'h', 'EXT:MODULE', 'handle files with extension EXT with module MODULE');
  cache$ = optionParser.parse(process.argv);
  options = cache$[0];
  positionalArgs = cache$[1];
  options.ignoreMissing = options['ignore-missing'];
  options.sourceMap = options['source-map'];
  options.inlineSources = options['inline-sources'];
  options.inlineSourceMap = options['inline-source-map'];
  options.aliases = {};
  for (var i$ = 0, length$ = options.alias.length; i$ < length$; ++i$) {
    aliasPair = options.alias[i$];
    match = aliasPair.match((cache$1 = /([^:]+):(.*)/, null != cache$1 ? cache$1 : []));
    if (null != match) {
      options.aliases[match[1]] = match[2];
    } else {
      console.error('invalid alias: ' + aliasPair);
      process.exit(1);
    }
  }
  options.handlers = {};
  for (var i$1 = 0, length$1 = options.handler.length; i$1 < length$1; ++i$1) {
    handlerPair = options.handler[i$1];
    match = handlerPair.match((cache$2 = /([^:]+):(.*)/, null != cache$2 ? cache$2 : []));
    if (null != match) {
      (function (ext, mod) {
        return options.handlers[ext] = require(mod);
      }('.' + match[1], match[2]));
    } else {
      console.error('invalid handler: ' + handlerPair);
      process.exit(1);
    }
  }
  if (options.help) {
    $0 = process.argv[0] === 'node' ? process.argv[1] : process.argv[0];
    $0 = path.basename($0);
    console.log('\n  Usage: ' + $0 + ' OPT* path/to/entry-file.ext OPT*\n\n' + optionParser.help() + '\n');
    process.exit(0);
  }
  if (options.version) {
    console.log(require('../package.json').version);
    process.exit(0);
  }
  if (!(positionalArgs.length === 1)) {
    console.error('wrong number of entry points given; expected 1');
    process.exit(1);
  }
  root = options.root ? path.resolve(options.root) : process.cwd();
  originalEntryPoint = positionalArgs[0];
  if (options.deps) {
    deps = CJSEverywhere.traverseDependencies(originalEntryPoint, root, options);
    for (_ in deps) {
      if (!isOwn$(deps, _))
        continue;
      dep = deps[_];
      console.log(dep.canonicalName);
    }
    process.exit(0);
  }
  if (options.watch && !options.output) {
    console.error('--watch requires --ouput');
    process.exit(1);
  }
  build = function (entryPoint, processed) {
    var bundled, cache$3, cache$4, canonicalName, code, datauri, e, esmangle, file, fileContents, filename, map, newDeps, sourceMappingUrl;
    if (null == processed)
      processed = {};
    try {
      newDeps = CJSEverywhere.traverseDependencies(entryPoint, root, options);
      if (options.watch)
        for (filename in newDeps) {
          if (!isOwn$(newDeps, filename))
            continue;
          dep = newDeps[filename];
          console.error('built ' + dep.canonicalName + ' (' + options.cache[filename] + ')');
        }
      for (file in newDeps) {
        if (!isOwn$(newDeps, file))
          continue;
        processed[file] = newDeps[file];
      }
    } catch (e$) {
      e = e$;
      if (options.watch) {
        console.error('ERROR: ' + e.message);
      } else {
        throw e;
      }
    }
    bundled = CJSEverywhere.bundle(processed, originalEntryPoint, root, options);
    if (options.minify) {
      esmangle = require('esmangle');
      bundled = esmangle.mangle(esmangle.optimize(bundled), { destructive: true });
    }
    cache$3 = escodegen.generate(bundled, {
      comment: !options.minify,
      sourceMap: true,
      sourceMapWithCode: true,
      sourceMapRoot: null != options.sourceMap ? path.relative(path.dirname(options.sourceMap), root) || '.' : void 0,
      format: options.minify ? escodegenCompactFormat : escodegenDefaultFormat
    });
    code = cache$3.code;
    map = cache$3.map;
    if ((options.sourceMap || options.inlineSourceMap) && options.inlineSources)
      for (filename in processed) {
        if (!isOwn$(processed, filename))
          continue;
        {
          cache$4 = processed[filename];
          canonicalName = cache$4.canonicalName;
          fileContents = cache$4.fileContents;
        }
        map.setSourceContent(canonicalName, fileContents);
      }
    if (options.sourceMap) {
      fs.writeFileSync(options.sourceMap, '' + map);
      sourceMappingUrl = options.output ? path.relative(path.dirname(options.output), options.sourceMap) : options.sourceMap;
      if (!options.inlineSourceMap)
        code = '' + code + '\n//# sourceMappingURL=' + sourceMappingUrl;
    }
    if (options.inlineSourceMap) {
      datauri = 'data:application/json;charset=utf-8;base64,' + btoa('' + map);
      code = '' + code + '\n//# sourceMappingURL=' + datauri;
    }
    if (options.output) {
      fs.writeFileSync(options.output, code);
    } else {
      process.stdout.write('' + code + '\n');
    }
    if (options.watch || options.verbose)
      console.error('BUNDLE COMPLETE');
    return processed;
  };
  startBuild = function () {
    var processed, startWatching, watching;
    if (options.watch) {
      options.cache = {};
      console.error('BUNDLING starting at ' + originalEntryPoint);
    }
    processed = build(originalEntryPoint);
    if (options.watch) {
      watching = [];
      return (startWatching = function (processed) {
        return function (accum$) {
          var canonicalName, file;
          for (file in processed) {
            if (!isOwn$(processed, file))
              continue;
            canonicalName = processed[file].canonicalName;
            if (!!in$(file, watching))
              continue;
            accum$.push(function (file, canonicalName) {
              watching.push(file);
              return fs.watchFile(file, {
                persistent: true,
                interval: 500
              }, function (curr, prev) {
                var ino;
                ino = process.platform === 'win32' ? null != curr.ino : curr.ino;
                if (!ino) {
                  console.error('WARNING: watched file ' + file + ' has disappeared');
                  return;
                }
                console.error('REBUNDLING starting at ' + canonicalName);
                processed = build(file, processed);
                startWatching(processed);
              });
            }(file, canonicalName));
          }
          return accum$;
        }.call(this, []);
      })(processed);
    }
  };
  if (originalEntryPoint === '-') {
    stdinput = '';
    process.stdin.on('data', function (data) {
      return stdinput += data;
    });
    process.stdin.on('end', function () {
      originalEntryPoint = require('mktemp').createFileSync('temp-XXXXXXXXX.js');
      fs.writeFileSync(originalEntryPoint, stdinput);
      process.on('exit', function () {
        return fs.unlinkSync(originalEntryPoint);
      });
      return startBuild();
    });
    process.stdin.setEncoding('utf8');
    process.stdin.resume();
  } else {
    startBuild();
  }
  function isOwn$(o, p) {
    return {}.hasOwnProperty.call(o, p);
  }
  function in$(member, list) {
    for (var i = 0, length = list.length; i < length; ++i)
      if (i in list && list[i] === member)
        return true;
    return false;
  }
}.call(this);
