// Generated by CoffeeScript 2.0.0-beta7
void function () {
  var btoa, bundle, cache$, canonicalise, escodegen, esprima, path, PRELUDE, PRELUDE_NODE, SourceMapConsumer, SourceMapGenerator, sourceMapToAst, wrap, wrapNode;
  esprima = require('esprima');
  path = require('path');
  cache$ = require('source-map');
  SourceMapConsumer = cache$.SourceMapConsumer;
  SourceMapGenerator = cache$.SourceMapGenerator;
  btoa = require('Base64').btoa;
  escodegen = require('escodegen');
  sourceMapToAst = require('./sourcemap-to-ast');
  canonicalise = require('./canonicalise');
  PRELUDE_NODE = "\n(function(){\n  var cwd = '/';\n  return {\n    title: 'browser',\n    version: '" + process.version + "',\n    browser: true,\n    env: {},\n    argv: [],\n    nextTick: global.setImmediate || function(fn){ setTimeout(fn, 0); },\n    cwd: function(){ return cwd; },\n    chdir: function(dir){ cwd = dir; }\n  };\n})()";
  PRELUDE = "\n(function() {\n  function require(file, parentModule){\n    if({}.hasOwnProperty.call(require.cache, file))\n      return require.cache[file];\n\n    var resolved = require.resolve(file);\n    if(!resolved) throw new Error('Failed to resolve module ' + file);\n\n    var module$ = {\n      id: file,\n      require: require,\n      filename: file,\n      exports: {},\n      loaded: false,\n      parent: parentModule,\n      children: []\n    };\n    if(parentModule) parentModule.children.push(module$);\n    var dirname = file.slice(0, file.lastIndexOf('/') + 1);\n\n    require.cache[file] = module$.exports;\n    resolved.call(module$.exports, module$, module$.exports, dirname, file);\n    module$.loaded = true;\n    return require.cache[file] = module$.exports;\n  }\n\n  require.modules = {};\n  require.cache = {};\n\n  require.resolve = function(file){\n    return {}.hasOwnProperty.call(require.modules, file) ? require.modules[file] : void 0;\n  };\n  require.define = function(file, fn){ require.modules[file] = fn; };\n\n  return require;\n)()";
  wrap = function (modules) {
    return '(function(global, require, undefined) {\n' + modules + '\n})(this, ' + PRELUDE + ');';
  };
  wrapNode = function (modules) {
    return '(function(global, require, process, undefined) {\n' + modules + '\n})(this, ' + PRELUDE + ', ' + PRELUDE_NODE + ');';
  };
  bundle = function (entryPoint, options) {
    var cache$1, code, filename, lineCount, lineOffset, map, name, orig, src, srcMap;
    code = '';
    map = new SourceMapGenerator({
      file: path.basename(options.outFile),
      sourceRoot: path.relative(path.dirname(options.outFile), options.root)
    });
    lineOffset = 1;
    for (filename in options.processed) {
      if (!isOwn$(options.processed, filename))
        continue;
      {
        cache$1 = options.processed[filename];
        name = cache$1.name;
        src = cache$1.src;
        srcMap = cache$1.srcMap;
        lineCount = cache$1.lineCount;
      }
      if (typeof name !== 'number')
        name = "'" + name + "'";
      code += '\nrequire.define(' + name + ', function(module, exports, __dirname, __filename){\n' + src + '\n});';
      lineOffset++;
      orig = new SourceMapConsumer(srcMap);
      orig.eachMapping(function (m) {
        return map.addMapping({
          generated: {
            line: m.generatedLine + lineOffset,
            column: m.generatedColumn
          },
          original: {
            line: m.originalLine || m.generatedLine,
            column: m.originalColumn || m.generatedColumn
          },
          source: filename
        });
      });
      lineOffset += lineCount + 1;
    }
    if (typeof entryPoint !== 'number')
      entryPoint = "'" + entryPoint + "'";
    code += '\nrequire(' + entryPoint + ');';
    if (options.node) {
      code = wrapNode(code);
    } else {
      code = wrap(code);
    }
    return {
      code: code,
      map: map
    };
  };
  module.exports = function (entryPoint, options) {
    var ast, cache$1, cache$2, code, datauri, esmangle, filename, map, src;
    cache$1 = bundle(entryPoint, options);
    code = cache$1.code;
    map = cache$1.map;
    if (options.minify) {
      esmangle = require('esmangle');
      ast = esprima.parse(bundled, { loc: true });
      sourceMapToAst(ast, srcMap);
      ast = esmangle.mangle(esmangle.optimize(ast), { destructive: true });
      cache$2 = escodegen.generate(ast, {
        sourceMap: true,
        format: escodegen.FORMAT_MINIFY,
        sourceMapWithCode: true,
        sourceMapRoot: null != options.sourceMap ? path.relative(path.dirname(options.sourceMap), options.root) || '.' : void 0
      });
      code = cache$2.code;
      map = cache$2.map;
      cache$2;
    }
    if ((options.sourceMap || options.inlineSourceMap) && options.inlineSources)
      for (filename in processed) {
        if (!isOwn$(processed, filename))
          continue;
        src = processed[filename].src;
        map.setSourceContent(filename, src);
      }
    if (options.inlineSourceMap) {
      datauri = 'data:application/json;charset=utf-8;base64,' + btoa('' + map);
      code = '' + code + '\n//# sourceMappingURL=' + datauri;
    }
    return {
      code: code,
      map: map
    };
  };
  function isOwn$(o, p) {
    return {}.hasOwnProperty.call(o, p);
  }
}.call(this);
