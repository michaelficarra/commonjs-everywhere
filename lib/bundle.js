// Generated by CoffeeScript 2.0.0-beta5
void function () {
  var canonicalise, esprima, PRELUDE, PRELUDE_NODE, wrapFile;
  esprima = require('esprima');
  canonicalise = require('./canonicalise');
  PRELUDE_NODE = "\nvar process = function(){\n  var cwd = '/';\n  return {\n    title: 'browser',\n    version: '" + process.version + "',\n    browser: true,\n    env: {},\n    argv: [],\n    nextTick: global.setImmediate || function(fn){ setTimeout(fn, 0); },\n    cwd: function(){ return cwd; },\n    chdir: function(dir){ cwd = dir; }\n  };\n}();";
  PRELUDE = "\nfunction require(file, parentModule){\n  if({}.hasOwnProperty.call(require.cache, file))\n    return require.cache[file];\n\n  var resolved = require.resolve(file);\n  if(!resolved) throw new Error('Failed to resolve module ' + file);\n\n  var module$ = {\n    id: file,\n    require: require,\n    filename: file,\n    exports: {},\n    loaded: false,\n    parent: parentModule,\n    children: []\n  };\n  if(parentModule) parentModule.children.push(module$);\n  var dirname = file.slice(0, file.lastIndexOf('/') + 1);\n\n  require.cache[file] = module$.exports;\n  resolved.call(module$.exports, module$, module$.exports, dirname, file);\n  module$.loaded = true;\n  return require.cache[file] = module$.exports;\n}\n\nrequire.modules = {};\nrequire.cache = {};\n\nrequire.resolve = function(file){\n  return {}.hasOwnProperty.call(require.modules, file) ? require.modules[file] : void 0;\n};\nrequire.define = function(file, fn){ require.modules[file] = fn; };";
  wrapFile = function (name, program) {
    var wrapper, wrapperProgram;
    wrapperProgram = esprima.parse('require.define(0, function(module, exports, __dirname, __filename){});');
    wrapper = wrapperProgram.body[0];
    wrapper.expression['arguments'][0] = {
      type: 'Literal',
      value: name
    };
    wrapper.expression['arguments'][1].body.body = program.body;
    return wrapper;
  };
  module.exports = function (processed, entryPoint, root, options) {
    var ast, exportExpression, filename, iife, lhsExpression, prelude, program, requireEntryPoint;
    prelude = (null != options.node ? options.node : true) ? '' + PRELUDE + '\n' + PRELUDE_NODE : PRELUDE;
    program = esprima.parse(prelude);
    for (filename in processed) {
      if (!isOwn$(processed, filename))
        continue;
      ast = processed[filename];
      program.body.push(wrapFile(ast.loc.source, ast));
    }
    requireEntryPoint = {
      type: 'CallExpression',
      callee: {
        type: 'Identifier',
        name: 'require'
      },
      'arguments': [{
          type: 'Literal',
          value: canonicalise(root, entryPoint)
        }]
    };
    if (null != options['export']) {
      exportExpression = esprima.parse(options['export']).body[0].expression;
      lhsExpression = exportExpression.type === 'Identifier' ? {
        type: 'MemberExpression',
        computed: false,
        object: {
          type: 'Identifier',
          name: 'global'
        },
        property: {
          type: 'Identifier',
          name: exportExpression.name
        }
      } : exportExpression;
      program.body.push({
        type: 'ExpressionStatement',
        expression: {
          type: 'AssignmentExpression',
          operator: '=',
          left: lhsExpression,
          right: requireEntryPoint
        }
      });
    } else {
      program.body.push({
        type: 'ExpressionStatement',
        expression: requireEntryPoint
      });
    }
    iife = esprima.parse('(function(global){}).call(this, this);');
    iife.body[0].expression.callee.object.body.body = program.body;
    iife.leadingComments = [{
        type: 'Line',
        value: ' Generated by CommonJS Everywhere ' + require('../package.json').version
      }];
    return iife;
  };
  function isOwn$(o, p) {
    return {}.hasOwnProperty.call(o, p);
  }
}.call(this);
