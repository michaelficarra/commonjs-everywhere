// Generated by CoffeeScript 2.0.0-beta4
void function () {
  var async, async_if, badRequireError, bundle, canonicalise, cjsify, cjsifySync, CoffeeScript, CORE_DIR, esprima, estraverse, fs, isCore, path, PRELUDE, relativeResolve, relativeResolveSync, resolve, resolvePath, resolvePathSync, traverseDependencies, traverseDependenciesSync, wrapFile;
  path = require('path');
  fs = require('fs');
  resolve = require('resolve');
  esprima = require('esprima');
  estraverse = require('estraverse');
  CoffeeScript = require('coffee-script-redux');
  async = require('async');
  async_if = function (test, consequent, alternate, cb) {
    test(function (err, bool) {
      if (null != err)
        return cb(err);
      if (bool) {
        consequent(cb);
      } else {
        alternate(cb);
      }
    });
  };
  CORE_DIR = path.join(__dirname, '..', 'core');
  isCore = function () {
    var coreFiles;
    coreFiles = fs.readdirSync(CORE_DIR);
    coreFiles = coreFiles.filter(function (f) {
      return !fs.statSync(path.join(CORE_DIR, f)).isDirectory();
    });
    coreFiles = coreFiles.map(function (f) {
      return f.replace(/\.js$/, '');
    });
    return function (x) {
      return resolve.isCore(x) || in$(x, coreFiles);
    };
  }();
  PRELUDE = "\nvar process = function(){\n  var cwd = '/';\n  return {\n    title: 'browser',\n    version: '" + process.version + "',\n    browser: true,\n    env: {},\n    argv: [],\n    nextTick: function(fn){ setTimeout(fn, 0); },\n    cwd: function(){ return cwd; },\n    chdir: function(dir){ cwd = dir; }\n  };\n}();\n\nfunction require(file, parentModule){\n  if({}.hasOwnProperty.call(require.cache, file))\n    return require.cache[file];\n\n  var resolved = require.resolve(file);\n  if(!resolved) throw new Error('Failed to resolve module ' + file);\n\n  var module$ = {\n    id: file,\n    require: require,\n    filename: file,\n    exports: {},\n    loaded: false,\n    parent: parentModule,\n    children: []\n  };\n  if(parentModule) parentModule.children.push(module$);\n  var dirname = file.slice(0, file.lastIndexOf('/') + 1);\n\n  require.cache[file] = module$.exports;\n  resolved.call(module$.exports, module$, module$.exports, dirname, file);\n  module$.loaded = true;\n  return require.cache[file] = module$.exports;\n}\n\nrequire.modules = {};\nrequire.cache = {};\n\nrequire.resolve = function(file){\n  return {}.hasOwnProperty.call(require.modules, file) ? require.modules[file] : void 0;\n};\nrequire.define = function(file, fn){ require.modules[file] = fn; };\n";
  wrapFile = function (name, program) {
    var wrapper, wrapperProgram;
    wrapperProgram = esprima.parse('require.define(0, function(module, exports, __dirname, __filename){});');
    wrapper = wrapperProgram.body[0];
    wrapper.expression['arguments'][0] = {
      type: 'Literal',
      value: name
    };
    wrapper.expression['arguments'][1].body.body = program.body;
    return wrapper;
  };
  bundle = function (processed, entryPoint, options) {
    var ast, exportExpression, filename, iife, lhsExpression, program, requireEntryPoint;
    program = esprima.parse(PRELUDE);
    for (filename in processed) {
      if (!isOwn$(processed, filename))
        continue;
      ast = processed[filename];
      program.body.push(wrapFile(ast.loc.source, ast));
    }
    requireEntryPoint = {
      type: 'CallExpression',
      callee: {
        type: 'Identifier',
        name: 'require'
      },
      'arguments': [{
          type: 'Literal',
          value: entryPoint
        }]
    };
    if (null != options['export']) {
      exportExpression = esprima.parse(options['export']).body[0].expression;
      lhsExpression = exportExpression.type === 'Identifier' ? {
        type: 'MemberExpression',
        computed: false,
        object: {
          type: 'Identifier',
          name: 'global'
        },
        property: {
          type: 'Identifier',
          name: exportExpression.name
        }
      } : exportExpression;
      program.body.push({
        type: 'ExpressionStatement',
        expression: {
          type: 'AssignmentExpression',
          operator: '=',
          left: lhsExpression,
          right: requireEntryPoint
        }
      });
    } else {
      program.body.push({
        type: 'ExpressionStatement',
        expression: requireEntryPoint
      });
    }
    iife = esprima.parse('(function(global){}).call(this, this);');
    iife.body[0].expression.callee.object.body.body = program.body;
    return iife;
  };
  badRequireError = function (filename, node, msg) {
    if (null != node.loc && null != (null != node.loc ? node.loc.start : void 0))
      filename = '' + filename + ':' + node.loc.start.line + ':' + node.loc.start.column;
    throw '\n    illegal require: ' + msg + '\n      `' + require('escodegen').generate(node) + '`\n      in ' + filename + '\n  ';
  };
  canonicalise = function (root, file) {
    return '/' + path.relative(root, file);
  };
  resolvePath = function (extensions, root, givenPath, cwd, cb) {
    var alternate, consequent, test;
    if (null == cb)
      cb = function () {
      };
    test = function (cb) {
      return cb(null, isCore(givenPath));
    };
    consequent = function (cb) {
      if (isCore(givenPath)) {
        givenPath = path.resolve(path.join(CORE_DIR, '' + givenPath + '.js'));
        return fs.exists(givenPath, function (exists) {
          if (exists) {
            return cb(null, givenPath);
          } else {
            throw new Error('Core module "' + givenPath + '" has not yet been ported to the browser');
          }
        });
      }
    };
    alternate = function (cb) {
      return cb(null, givenPath);
    };
    return async_if(test, consequent, alternate, function (err, givenPath) {
      if (null != err)
        return cb(err);
      return resolve(givenPath, {
        basedir: cwd || root,
        extensions: extensions
      }, function (err, resolved) {
        if (resolved)
          return process.nextTick(function () {
            return cb(null, resolved);
          });
        return resolve(path.join(root, givenPath), { extensions: extensions }, function (err, resolved) {
          if (resolved)
            return process.nextTick(function () {
              return cb(null, resolved);
            });
          return process.nextTick(function () {
            return cb(new Error('Cannot find module "' + givenPath + '" in "' + root + '"'));
          });
        });
      });
    });
  };
  resolvePathSync = function (extensions, root, givenPath, cwd) {
    var e;
    if (isCore(givenPath)) {
      givenPath = path.resolve(path.join(CORE_DIR, '' + givenPath + '.js'));
      if (!fs.existsSync(givenPath))
        throw new Error('Core module "' + givenPath + '" has not yet been ported to the browser');
    }
    try {
      return resolve.sync(givenPath, {
        basedir: cwd || root,
        extensions: extensions
      });
    } catch (e$) {
      e = e$;
      try {
        return resolve.sync(path.join(root, givenPath), { extensions: extensions });
      } catch (e$1) {
        e = e$1;
        throw new Error('Cannot find module "' + givenPath + '" in "' + root + '"');
      }
    }
  };
  relativeResolve = function (extensions, root, givenPath, cwd, cb) {
    if (null == cb)
      cb = function () {
      };
    return resolvePath(extensions, root, givenPath, cwd, function (err, resolved) {
      if (null != err)
        return cb(err);
      return cb(null, isCore(givenPath) ? givenPath : canonicalise(root, resolved));
    });
  };
  relativeResolveSync = function (extensions, root, givenPath, cwd) {
    var resolved;
    resolved = resolvePathSync(extensions, root, givenPath, cwd);
    if (isCore(givenPath)) {
      return givenPath;
    } else {
      return canonicalise(root, resolved);
    }
  };
  traverseDependencies = function (entryPoint, root, options, cb) {
    var aliases, cache$, ext, extensions, handler, handlers, processed, q, work;
    if (null == root)
      root = process.cwd();
    if (null == options)
      options = {};
    if (null == cb)
      cb = function () {
      };
    aliases = null != options.aliases ? options.aliases : {};
    handlers = {
      '.coffee': function (coffee, canonicalName) {
        return CoffeeScript.compile(CoffeeScript.parse(coffee, { raw: true }), { bare: true });
      },
      '.json': function (json, canonicalName) {
        return esprima.parse('module.exports = ' + json, {
          loc: true,
          source: canonicalName
        });
      }
    };
    for (ext in cache$ = null != options.handlers ? options.handlers : {}) {
      if (!isOwn$(cache$, ext))
        continue;
      handler = cache$[ext];
      handlers[ext] = handler;
    }
    extensions = ['.js'].concat([].slice.call(function (accum$) {
      for (ext in handlers) {
        if (!isOwn$(handlers, ext))
          continue;
        accum$.push(ext);
      }
      return accum$;
    }.call(this, [])));
    processed = {};
    q = null;
    work = function (param$, next) {
      var alternate, cache$1, canonicalName, consequent, filename, test;
      {
        cache$1 = param$;
        filename = cache$1.filename;
        canonicalName = cache$1.canonicalName;
      }
      if ({}.hasOwnProperty.call(processed, filename))
        return next();
      test = function (cb) {
        return cb(null, {}.hasOwnProperty.call(aliases, canonicalName));
      };
      consequent = function (cb) {
        return resolvePath(extensions, root, aliases[canonicalName], cb);
      };
      alternate = function (cb) {
        return cb(null, filename);
      };
      return async_if(test, consequent, alternate, function (err, filename) {
        var extname;
        if (null != err)
          return next(err);
        extname = path.extname(filename);
        return fs.readFile(filename, function (err, fileContents) {
          var ast, e;
          if (null != err)
            return next(err);
          processed[filename] = ast = {}.hasOwnProperty.call(handlers, extname) ? handlers[extname](fileContents, canonicalName) : esprima.parse(fileContents, {
            loc: true,
            source: canonicalName
          });
          if (null != ast.loc)
            ast.loc;
          else
            ast.loc = {};
          try {
            estraverse.replace(ast, {
              enter: function (node, parents) {
                var cwd, e, targetCanonicalName;
                if (null != node.loc)
                  node.loc.source = canonicalName;
                if (!(node.type === 'CallExpression' && node.callee.type === 'Identifier' && node.callee.name === 'require'))
                  return;
                if (!(node['arguments'].length === 1))
                  badRequireError(filename, node, 'require must be given exactly one argument');
                if (!(node['arguments'][0].type === 'Literal' && typeof node['arguments'][0].value === 'string'))
                  badRequireError(filename, node, 'argument of require must be a constant string');
                cwd = path.dirname(fs.realpathSync(filename));
                if (options.verbose)
                  console.error('required "' + node['arguments'][0].value + '" from "' + canonicalName + '"');
                try {
                  targetCanonicalName = relativeResolveSync(extensions, root, node['arguments'][0].value, cwd);
                  q.push({
                    filename: resolvePathSync(extensions, root, node['arguments'][0].value, cwd),
                    canonicalName: targetCanonicalName
                  });
                } catch (e$) {
                  e = e$;
                  if (options.ignoreMissing) {
                    return {
                      type: 'Literal',
                      value: null
                    };
                  } else {
                    throw e;
                  }
                }
                return {
                  type: 'CallExpression',
                  callee: node.callee,
                  'arguments': [
                    {
                      type: 'Literal',
                      value: targetCanonicalName
                    },
                    {
                      type: 'Identifier',
                      name: 'module'
                    }
                  ]
                };
              }
            });
          } catch (e$) {
            e = e$;
            return next(e);
          }
          return next();
        });
      });
    };
    process.nextTick(function () {
      q = async.queue(work, 9e9);
      q.drain = function (err) {
        return cb(err, processed);
      };
      return q.push({
        filename: path.resolve(entryPoint),
        canonicalName: canonicalise(root, entryPoint)
      });
    });
  };
  traverseDependenciesSync = function (entryPoint, root, options) {
    var aliases, ast, cache$, cache$1, canonicalName, ext, extensions, extname, fileContents, filename, handler, handlers, processed, worklist;
    if (null == root)
      root = process.cwd();
    if (null == options)
      options = {};
    aliases = null != options.aliases ? options.aliases : {};
    handlers = {
      '.coffee': function (coffee, canonicalName) {
        return CoffeeScript.compile(CoffeeScript.parse(coffee, { raw: true }), { bare: true });
      },
      '.json': function (json, canonicalName) {
        return esprima.parse('module.exports = ' + json, {
          loc: true,
          source: canonicalName
        });
      }
    };
    for (ext in cache$ = null != options.handlers ? options.handlers : {}) {
      if (!isOwn$(cache$, ext))
        continue;
      handler = cache$[ext];
      handlers[ext] = handler;
    }
    extensions = ['.js'].concat([].slice.call(function (accum$) {
      for (ext in handlers) {
        if (!isOwn$(handlers, ext))
          continue;
        accum$.push(ext);
      }
      return accum$;
    }.call(this, [])));
    worklist = [{
        filename: path.resolve(entryPoint),
        canonicalName: canonicalise(root, entryPoint)
      }];
    processed = {};
    while (worklist.length) {
      cache$1 = worklist.pop();
      filename = cache$1.filename;
      canonicalName = cache$1.canonicalName;
      if ({}.hasOwnProperty.call(processed, filename))
        continue;
      if ({}.hasOwnProperty.call(aliases, canonicalName))
        filename = resolvePathSync(extensions, root, aliases[canonicalName]);
      extname = path.extname(filename);
      fileContents = fs.readFileSync(filename);
      processed[filename] = ast = {}.hasOwnProperty.call(handlers, extname) ? handlers[extname](fileContents, canonicalName) : esprima.parse(fileContents, {
        loc: true,
        source: canonicalName
      });
      if (null != ast.loc)
        ast.loc;
      else
        ast.loc = {};
      estraverse.replace(ast, {
        enter: function (node, parents) {
          var cwd, e, targetCanonicalName;
          if (null != node.loc)
            node.loc.source = canonicalName;
          if (!(node.type === 'CallExpression' && node.callee.type === 'Identifier' && node.callee.name === 'require'))
            return;
          if (!(node['arguments'].length === 1))
            badRequireError(filename, node, 'require must be given exactly one argument');
          if (!(node['arguments'][0].type === 'Literal' && typeof node['arguments'][0].value === 'string'))
            badRequireError(filename, node, 'argument of require must be a constant string');
          cwd = path.dirname(fs.realpathSync(filename));
          if (options.verbose)
            console.error('required "' + node['arguments'][0].value + '" from "' + canonicalName + '"');
          try {
            targetCanonicalName = relativeResolveSync(extensions, root, node['arguments'][0].value, cwd);
            worklist.push({
              filename: resolvePathSync(extensions, root, node['arguments'][0].value, cwd),
              canonicalName: targetCanonicalName
            });
          } catch (e$) {
            e = e$;
            if (options.ignoreMissing) {
              return {
                type: 'Literal',
                value: null
              };
            } else {
              throw e;
            }
          }
          return {
            type: 'CallExpression',
            callee: node.callee,
            'arguments': [
              {
                type: 'Literal',
                value: targetCanonicalName
              },
              {
                type: 'Identifier',
                name: 'module'
              }
            ]
          };
        }
      });
    }
    return processed;
  };
  cjsify = function (entryPoint, root, options, cb) {
    if (null == root)
      root = process.cwd();
    if (null == options)
      options = {};
    if (null == cb)
      cb = function () {
      };
    return traverseDependencies(entryPoint, root, options, function (err, processed) {
      if (err)
        return process.nextTick(function () {
          return cb(err);
        });
      if (options.verbose)
        console.error('\nIncluded modules:\n  ' + Object.keys(processed).sort().join('\n  '));
      return cb(null, bundle(processed, canonicalise(root, entryPoint), options));
    });
  };
  cjsifySync = function (entryPoint, root, options) {
    var processed;
    if (null == root)
      root = process.cwd();
    if (null == options)
      options = {};
    processed = traverseDependenciesSync(entryPoint, root, options);
    if (options.verbose)
      console.error('\nIncluded modules:\n  ' + Object.keys(processed).sort().join('\n  '));
    return bundle(processed, canonicalise(root, entryPoint), options);
  };
  exports.bundle = bundle;
  exports.cjsify = cjsify;
  exports.cjsifySync = cjsifySync;
  exports.traverseDependencies = traverseDependencies;
  exports.traverseDependenciesSync = traverseDependenciesSync;
  if ('undefined' !== typeof IN_TESTING_ENVIRONMENT && null != IN_TESTING_ENVIRONMENT) {
    exports.badRequireError = badRequireError;
    exports.canonicalise = canonicalise;
    exports.isCore = isCore;
    exports.relativeResolve = relativeResolve;
    exports.relativeResolveSync = relativeResolveSync;
    exports.resolvePath = resolvePath;
    exports.resolvePathSync = resolvePathSync;
    exports.wrapFile = wrapFile;
  }
  function in$(member, list) {
    for (var i = 0, length = list.length; i < length; ++i)
      if (i in list && list[i] === member)
        return true;
    return false;
  }
  function isOwn$(o, p) {
    return {}.hasOwnProperty.call(o, p);
  }
}.call(this);
