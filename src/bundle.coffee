esprima = require 'esprima'

canonicalise = require './canonicalise'

PRELUDE_NODE = """
var process = function(){
  var cwd = '/';
  return {
    title: 'browser',
    version: '#{process.version}',
    browser: true,
    env: {},
    argv: [],
    nextTick: global.setImmediate || function(fn){ setTimeout(fn, 0); },
    cwd: function(){ return cwd; },
    chdir: function(dir){ cwd = dir; }
  };
}();
"""

PRELUDE = """
function require(file, parentModule){
  if({}.hasOwnProperty.call(require.cache, file))
    return require.cache[file];

  var resolved = require.resolve(file);
  if(!resolved) throw new Error('Failed to resolve module ' + file);

  var module$ = {
    id: file,
    require: require,
    filename: file,
    exports: {},
    loaded: false,
    parent: parentModule,
    children: []
  };
  if(parentModule) parentModule.children.push(module$);
  var dirname = file.slice(0, file.lastIndexOf('/') + 1);

  require.cache[file] = module$.exports;
  resolved.call(module$.exports, module$, module$.exports, dirname, file);
  module$.loaded = true;
  return require.cache[file] = module$.exports;
}

require.modules = {};
require.cache = {};

require.resolve = function(file){
  return {}.hasOwnProperty.call(require.modules, file) ? require.modules[file] : void 0;
};
require.define = function(file, fn){ require.modules[file] = fn; };
"""

wrapFile = (name, program, uidFor) ->
  wrapperProgram = esprima.parse 'require.define(0, function(module, exports, __dirname, __filename){});'
  wrapper = wrapperProgram.body[0]
  wrapper.expression.arguments[0] = { type: 'Literal', value: if uidFor then uidFor(name) else name }
  wrapper.expression.arguments[1].body.body = program.body
  wrapper

module.exports = (processed, entryPoint, root, options) ->
  prelude = if options.node ? yes then "#{PRELUDE}\n#{PRELUDE_NODE}" else PRELUDE
  program = esprima.parse prelude
  uidFor = options.uidFor
  for own filename, {ast} of processed
    program.body.push wrapFile ast.loc.source, ast, uidFor

  canonicalEntryPoint = canonicalise root, entryPoint

  requireEntryPoint =
    type: 'CallExpression'
    callee: { type: 'Identifier', name: 'require' }
    arguments: [{ type: 'Literal', value: if uidFor then uidFor(canonicalEntryPoint) else canonicalEntryPoint }]

  # require/expose the entry point
  if options.export?
    exportExpression = (esprima.parse options.export).body[0].expression
    lhsExpression =
      if exportExpression.type is 'Identifier'
        type: 'MemberExpression'
        computed: false
        object: { type: 'Identifier', name: 'global' }
        property: { type: 'Identifier', name: exportExpression.name }
      else
        exportExpression
    program.body.push
      type: 'ExpressionStatement'
      expression:
        type: 'AssignmentExpression'
        operator: '='
        left: lhsExpression
        right: requireEntryPoint
  else
    program.body.push
      type: 'ExpressionStatement'
      expression: requireEntryPoint

  # wrap everything in IIFE for safety; define global var
  iife = esprima.parse '(function(global){}).call(this, this);'
  iife.body[0].expression.callee.object.body.body = program.body
  iife.leadingComments = [
    type: 'Line'
    value: " Generated by CommonJS Everywhere #{(require '../package.json').version}"
  ]

  iife
